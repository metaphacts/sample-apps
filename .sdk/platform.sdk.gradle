/*
 * Platform SDK definiton
 *
 * (c) 2022 metaphacts GmbH
 *
 * This script is assumed to be included into the root project
 */


def webappDir = file("target/webapp/");
def runtimeDir = rootProject.file(setting('runtimeDirectory', 'RUNTIME_DIRECTORY', 'runtime'))
def appRuntimeDir = file("target/runtime-apps");
def selectedRuntimeApps = findRuntimeAppProjects();
def logProfile = setting('log', 'LOG', 'log4j2-debug')



// logging of existing platform binary distribution
if (webappDir.exists()) {
	// TODO extract version from manifest and log on lifecycle
	logger.info("Using prepared platform binary from " + webappDir)
}

task unzipWar(type: Copy) {

	def platformWar = setting('platformLocation', 'PLATFORM_LOCATION', null);
	if (platformWar == null) {
		throw new GradleException("Platform location is not defined. Hint: Use platformLocation setting in gradle.properties");
	}
	if (!file(platformWar).isFile()) {
		throw new GradleException("Platform WAR binary does not exist at " + platformWar);
	}
	def zipFile = file(platformWar)
	def outputDir = webappDir
 
	from zipTree(zipFile)
	into outputDir
	
	doFirst {
		logger.lifecycle("Extracting platform WAR binary from " + file(platformWar))
	}
}

task cleanWebapp(type: Delete) {
	delete webappDir
}

task prepareEnvironment(dependsOn: [cleanWebapp, unzipWar]) {

}


task clean() {
	delete 'target/apps'
}

// define additional dependencies for app projects
if (webappDir.exists()) {
	
	project.afterEvaluate {
		configure(appProjects) {
			
			repositories {
				flatDir {
					dirs new File(webappDir, "WEB-INF/lib")
				}
			}

			dependencies {
				compileOnly name: 'metaphactory'
			}
		}
	}
}


/*
 * Configures a virtual Jetty project which serves as a launcher
 * for the platform
 */
configure(project(':jetty')) {

	apply plugin: "org.gretty"
	apply plugin: "war"
	
	repositories {
		maven { 
			url "https://plugins.gradle.org/m2/"
		}

	}
	
	ext {
		JETTY_VERSION = '9.4.46.v20220331'
	}
	
	dependencies {
		// make dependencies available for source code resolution when debugging Jetty code in the IDE
		// this code is not used for compilation or other access
		runtimeOnly group: 'org.eclipse.jetty', name: 'jetty-server', version: JETTY_VERSION
		runtimeOnly group: 'org.eclipse.jetty', name: 'jetty-servlet', version: JETTY_VERSION
	}
	
	buildDir = rootProject.file('target/jetty/')
	webAppDirName = rootProject.file('target/webapp')
	
	gretty {
		inplaceMode='hard'
		loggingLevel='INFO'
		contextPath=''
		httpPort=10214
		jetty94Version = JETTY_VERSION
		
		jvmArgs = []
		
		// dev environment settings
		jvmArgs << "-DruntimeDirectory=" + runtimeDir
		jvmArgs << "-DappsDirectory=" + appRuntimeDir
		jvmArgs << "-Dcom.metaphacts.config.baselocation=" + (new File(runtimeDir, 'config'))
		jvmArgs << "-Dconfig.mutablePluginApps=false"
		jvmArgs << "-Dlog4j.configurationFile=" + rootProject.file('target/webapp/etc/' + logProfile + '.xml')
		jvmArgs << "-Dconfig.environment.shiroConfig=" + new File(runtimeDir, 'config/shiro.ini')
		jvmArgs << "-Dorg.eclipse.jetty.annotations.LEVEL=OFF"
		
		// platform settings
		for (String key : System.getProperties().keySet()) {
			if (key.startsWith('config.') || key.startsWith('appsDirectory')) {
				jvmArgs << '-D' + key + '=' + System.getProperties().get(key)
			}
		}
		
		// jetty parameters
		jvmArgs << "-Dorg.eclipse.jetty.server.Request.maxFormContentSize=100000000"
		
		if (Boolean.parseBoolean(setting('debug', 'DEBUG', 'false'))) {
			def port = setting('debug.port', 'DEBUG_PORT', '5005')
			def suspend = Boolean.parseBoolean(setting('debug.suspend', 'DEBUG_SUSPEND', 'true')) ? 'y' : 'n'
			jvmArgs << '-Xdebug'
			jvmArgs << '-Xrunjdwp:transport=dt_socket,server=y,suspend=' + suspend + ',address=' + port
		}
		
		if (rootProject.file('target/jetty/webapp').isFile()) {
			extraResourceBase rootProject.file('target/jetty/webapp')
		}
	}
	
	task checkEnvironment() {
		doLast {
			if (!rootProject.file('target/webapp').exists()) {
				project.logger.warn("It looks like your environment is not setup correctly: could not find platform binary distribution")
				project.logger.warn("Location can be specified using 'platformLocation' in gradle.properties, and then running 'gradlew prepareEnvironment'")
				throw new GradleException("Environment is not setup correctly. See logs above for details")
			}
		}
	}
	
		
	task cleanRuntimeApps(type: Delete) {
		delete appRuntimeDir
	}
	task cleanJetty(type: Delete) {
		delete rootProject.file('target/jetty')
	}
	clean.dependsOn cleanJetty
	
	
	task cleanRuntimeDir(type: Delete) {
		delete runtimeDir;
	}
	
	task prepareRuntime() {
		doLast {
			project.logger.lifecycle("Using runtime directory: " + runtimeDir);
			if (!runtimeDir.isDirectory()) {
				runtimeDir.mkdirs();
			}
			if (!(new File(runtimeDir, 'config/shiro.ini').isFile())) {
				project.copy {
					from rootProject.file('.sdk/shiro.ini')
					into new File(runtimeDir, 'config')
				}
			}
		}
	}
	
	task prepareRuntimeApps(type: Copy) {
	
		into appRuntimeDir;
		
		if (selectedRuntimeApps.isEmpty()) {
			project.logger.info("No apps specified as runtime artifacts. Hint: specify 'apps' property in gradle.properties")
		}
		
		doFirst {
			project.logger.lifecycle("Preparing runtime for the following apps: " + selectedRuntimeApps);
		}
		
		for (def runtimeAppProject : selectedRuntimeApps) {
			into(runtimeAppProject.name) {
				from runtimeAppProject.file('target/deploy')
			}
		}
	}
	
	project.afterEvaluate {
		for (def runtimeAppProject : selectedRuntimeApps) {
			prepareRuntimeApps.dependsOn runtimeAppProject.getTasksByName("deploy", false)
		}
	}
	
	task refreshRuntimeApps(dependsOn: [cleanRuntimeApps, prepareRuntimeApps])
	
	task prepareWebapp(type: Copy) {
		
	}

	
	task appRunPrepare;
	
	project.afterEvaluate {
		appRunPrepare.dependsOn checkEnvironment
		appRunPrepare.dependsOn prepareWebapp
		appRunPrepare.dependsOn prepareRuntime
		appRunPrepare.dependsOn refreshRuntimeApps
		
		appRun.dependsOn appRunPrepare
		
		appStart.dependsOn appRunPrepare
	}

}



/**
 * Retrieves an externally provided setting by inspecting
 *
 * project -> system property -> environment -> defaultValue
 */
def setting(String propertyName, String envName, String defaultValue) {
	if (project.hasProperty(propertyName)) {
		return project.getProperty(propertyName)
	}
	if (System.properties[propertyName] != null) {
		return System.properties[propertyName];
	}
	if (System.getenv(envName) != null) {
		return System.getenv(envName);
	}
	return defaultValue;
}

/**
 * Inspects the setting "apps" for a app identifiers.
 * This is a comma separated list of app names corresponding
 * to the Gradle project name.
 */
def findRuntimeAppProjects() {

	String appsSetting = setting("apps", "APPS", null);
	if (appsSetting == null) {
		return [];
	}
	
	def appProjects = [];
	for (String appId : appsSetting.split(",")) {
		def _matchingProjects = allprojects.findAll { it.name == appId.trim() }
		if (_matchingProjects.isEmpty()) {
			project.logger.warn("No matching app projects found for " + appId);
		}
		appProjects.addAll(_matchingProjects)
	}
	
	return appProjects;
}
